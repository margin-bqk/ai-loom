## LOOM

**Language-Oriented Open Mythos**  
**语言驱动的开放叙事神话运行时**

---

## 0\. 一句话定义

**LOOM 是一个以语言为核心的叙事运行时：世界由文字编织，而不是由代码驱动。**

---

## 1\. 项目定位（Project Positioning）

LOOM 是一个 **LLM 原生（LLM-native）** 的叙事运行时，用于：

- AI Roleplay
- 互动小说
- 跑团式叙事
- 可长期运行的故事世界

与传统游戏引擎、规则引擎或 AI Dungeon 类产品不同，LOOM：

- **不** 在框架中固化任何玩法规则
- **不** 实现数值化模拟（HP / 数值判定 / 状态机）
- **不** 将世界逻辑写入代码

LOOM 的核心假设是：

- **Markdown 文档 = 世界宪法**
- **LLM = 规则的解释者与叙事者**
- **玩家 = 共创作者，而不是操作者**
- **运行时 = 中立的织机**

> LOOM 不决定世界如何运转，  
> 它只确保世界可以持续存在。

---

## 2\. 设计哲学（Design Philosophy）

### 2.1 非承载式架构（Non-Load-Bearing Architecture）

LOOM 采用 **非承载式设计** ：

- 框架本身不承载任何叙事规则
- 所有世界规则完全存在于框架之外
- 仅通过修改 Markdown，即可创建一个全新的游戏 / 世界

如果移除框架，规则依然是完整、可读的文本。  
如果移除规则，框架依然可以正常运行。

> 框架 ≠ 世界  
> 框架 ≠ 规则  
> 框架只是让“世界持续发生”的装置

---

### 2.2 语言是第一控制面（Language-First）

LOOM 认为：

- 自然语言足以描述复杂规则
- LLM 能理解“软约束”
- 一致性 > 精确性
- 意义 > 机制

因此：

- 规则是 **描述性的** ，而非过程式
- 约束是 **语义层面的** ，而非数值层面的
- 结果是 **叙事解释** ，而非算法计算

---

### 2.3 持久性优先于精确性

LOOM 优先考虑：

- 世界长期运行
- 记忆连续性
- Canon 一致性
- 情感与叙事因果

而非：

- 数值平衡
- 最优策略
- 确定性结果
- 机械公平性

---

## 3\. 项目目标（Project Goals）

### 核心目标

1. 支持 **BYOK（Bring Your Own Key）** 的 LLM 接入
2. 支持 **可无限延续的世界运行**
3. 仅通过修改 Markdown 即可彻底改变游戏体验
4. 支持玩家干预而不破坏沉浸感
5. 对 coding agent / 自动化友好

### 明确不做的事情（Non-Goals）

- 不做传统 RPG 系统
- 不实现战斗数值与技能树
- 不追求物理 / 经济模拟真实性
- 不做“游戏引擎”
- 不试图防止玩家“作弊”

---

## 4\. 核心概念模型（Conceptual Model）

LOOM 由 **五个严格解耦的逻辑层** 构成。

任何一层都 **不允许** 假设其他层的内部实现。

---

## 5\. 五个逻辑层（Five Logical Layers）

### 5.1 运行时核心层（Runtime Core）

**职责：**  
生命周期管理、调度与持久化。

**明确不知道的事情：**

- 剧情内容
- 世界规则
- 游戏类型
- 玩家身份

**负责内容包括：**

- Session 管理
- Prompt 组装
- Memory 读写
- 回合调度
- 崩溃恢复与安全边界

该层必须保持 **叙事失明** 。

---

### 5.2 规则层（Rule Layer / Markdown Canon）

**职责：**  
定义世界“应该如何运作”。

规则以 **纯 Markdown** 编写，例如：

- 世界观与形而上学
- 叙事基调与风格
- 冲突解决哲学
- 玩家权限边界
- 死亡、时间、因果关系

规则具备以下特性：

- 人类可读
- LLM 可解释
- 可版本控制
- 可热加载

**规则永远不会被翻译成代码。**

---

### 5.3 解释层（Interpretation Layer / LLM Reasoning）

**职责：**  
在 **每一回合** 解释规则，而不是预编译规则。

每一回合中，LLM 需要：

1. 重新理解当前规则集
2. 分析玩家输入
3. 推导符合规则的叙事结果
4. 与世界记忆保持一致

该层刻意保持：

- 非确定性
- 软逻辑
- 启发式推理

---

### 5.4 世界记忆层（World Memory Layer）

**职责：**  
保存“已经成为事实的东西”。

记忆不是全文日志，而是 **结构化叙事状态** 。

常见分类包括：

- Canon 事实
- 角色与实体
- 正在进行的剧情线
- 已确立的地点
- 叙事风格偏移

LLM 永远只看到 **相关摘要** ，而非完整历史。

---

### 5.5 玩家干预层（Player Intervention Layer）

**职责：**  
允许玩家作为共创作者介入世界。

支持的交互方式包括：

- OOC 注释
- 世界编辑
- Retcon（追溯性修改）
- 基调调整
- 叙事意图声明

系统应尽量 **吸收玩家意图，而非拒绝** 。

---

## 6\. 初步技术选型（Initial Tech Stack）

### Runtime

- Python
- Async 执行模型

### 存储

- SQLite / DuckDB（结构化状态）
- Markdown（规则）
- 可选向量库（仅用于 recall）

### LLM 接入

- BYOK
- Provider 无关
- Prompt-first 设计

### 版本控制

- Git 管理规则演化
- Session 可回放

---

## 7\. 预期使用场景（Usage Patterns）

LOOM 适用于：

- 个人 AI Dungeon
- 单人 / 多人叙事沙盒
- 长期运行的虚构世界
- LLM 叙事行为实验
- 叙事 Agent 的底层运行时

---

## 8\. 与 RUNE 的关系（Relationship to RUNE）

**RUNE**  
Runtime for Unified Narrative Engines  
→ 结构化、引擎导向、规则内置

**LOOM**  
Language-Oriented Open Mythos  
→ 解释式、世界导向、规则外置

RUNE 执行叙事。  
LOOM 让叙事 **生长** 。

它们共享理念，而非层级。

---

## 9\. 指导原则（Guiding Principle）

> **如果只改 Markdown 还不足以创造一个新世界，  
> 那么框架就已经越界了。**